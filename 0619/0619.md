## Overview
- General overview
- Scalar
- Scalar 연산
- Vector
- Vector 연산
- 조건문
- 반복문

## General overview
- 알고리즘 짜기
    - 함수
        - 인풋 -> 아웃풋
    - 필요 요소
        - 데이터 (인풋, 아웃풋, 중간 데이터)
        - 연산 (함수는 여러 연산이 순서대로 행해지는 것)
- 그래서 우리는 **데이터**와 **연산**에 대해 배우는 것이 전부!
- 데이터 종류 (Data type)
    - Scalar
    - Vector
    - Matrix
    - Factor
    - List
    - Array
    - Data Frame
- 연산
    - 기본 연산
    - 조건문
    - 반복문
    - 함수
    - 패키지 가져다 쓰기

## Scalar
- 단일 차원의 값. 값 1개.
- `typeof()` 함수를 사용하면 더 자세한 데이터 타입을 알 수 있음.
- Numeric 
    - 정수 integer
        - 0L, -1L, ...
    - 소수 double
        - 3.14, -2, ...
- Character
    - 문자
    - 'a', "abc"
- Logical
    - 진리값
    - TRUE, FALSE, T, F
- [참고](http://sjh836.tistory.com/112?category=719115)

## Scalar 연산
- Arithmetic 연산 (Numeric 데이터의 연산)
    - 사칙 연산: + - * /
    - %%: a %% b == a를 b로 나눈 나머지
    - %/%: a %/% b == a를 b로 나눈 몫
    - 예)
        ```R
        # 10을 3으로 나눈 나머지는 1
        > 10 %% 3
        [1] 1

        # 10을 3으로 나눈 몫은 3
        > 10 %/% 3
        [1] 3
        ```
- Logical 연산
    - `!` (not)
        - not True == False
        - not False == True
    - `&` (and, 교집합, *)
        - True and True == True
        - True and False == False
        - False and True == False
        - False and False == False
    - `|` (or, 합집합, +)
        - True or True == True
        - True or False == True
        - False or True == True
        - False or False == False
    - 예) 
        ```R
        # not TRUE == FALSE
        > ! T
        [1] FALSE

        # and 예제: x가 3일 때, 1 <= x <= 5 는 TRUE이다.
        > x <- 3
        > (1 <= x) & (x <= 5)
        [1] TRUE
        ```
- 비교 연산
    - == (같은지)
    - != (다른지)
    - \>
    - <
    - \>=
    - \<=
    - 예)
        ```R
        # Character도 대소비교 가능!
        # 사전순 배열을 했을 때, 'aaa'가 'b' 보다 앞에 나오니까 'aaa' < 'b' 이다.
        > 'aaa' < 'b'
        [1] TRUE
        ```

## Vector
- 여러 차원의 값. 값 여러 개. 원소를 순서대로 보관
    - ex) `c(1, 2, 3, 4)`
- 한 종류의 스칼라 데이터 타입만 가짐
    - 만약 서로 다른 스칼라 데이터타입이 섞여있다면 자동 형변환을 통해 하나의 데이터타입으로 통일함
    - 예)
        ```R
        # 하나의 벡터는 numeric과 character를 섞어 가질 수 없음.
        # 1, 2, 'a' 는 모두 character인 '1', '2', 'a' 로 변경되어 저장됨.
        > c(1, 2, 'a')
        [1] "1" "2" "a"
        ```

## Vector 연산
- Scalar 연산 그대로 사용
    - 단 element-wise 연산을 하게 됨.
    - 즉 같은 번째의 원소들끼리 scalar 연산이 적용됨
    - ex)
        ```R
        # 1번째 원소: 1 < 2 == TRUE
        # 1번째 원소: 2 < 2 == FALSE
        # 1번째 원소: 3 < 2 == FALSE
        > c(1, 2, 3) < c(2, 2, 2)
        [1]  TRUE FALSE FALSE
        ```
- `%in%`: Membership 연산
    - 어떤 원소가 저 벡터 안에 들어있는지를 체크
    - ex)
        ```R
        > 1 %in% c(1, 2, 3)
        [1] TRUE
        ```
- Vector 만들기
    - `from:to`
        - from부터 to까지의 정수 벡터 만들기
        - 원소들이 1씩 증가하거나 1씩 감소하는 벡터가 만들어짐
        - 예)
            ```R
            # -2부터 3까지, 1씩 증가
            > -2: 3
            [1] -2 -1  0  1  2  3

            # 6부터 3까지, 1씩 감소
            > 6:3
            [1] 6 5 4 3
            ```

- 1:3
- seq()
- rep(1:3, each=2, times=3)

## 변수 정의 / 선언
- 변수이름 <- 값
- 변수 이름
    - 한글 O
    - 영어 O
        - 대문자 소문자 구분
    - 숫자 O
        - 숫자로 시작하면 안된다
    - 언더바 가능
        - 스페이스 마냥 사용
    - .


## 조건문
- if
    
    x <-

    x가 2의배수이고 3의배수이면 6의 배수이다

    if (x가 2 의 배수){
        if (x 가 3의 배수){
            print('x는 6의 배수이다')
        }
    }

    if (조건){
        행위1
        행위1
        if (){

        }
    }

    y = 3

    if (1 <= x <= 5) {
        y = 0
    } 

- if else

    if (짝수){
        print('짝수')
    }
    else{
        print('홀수')
    }


- 
조건 1 --> do1
조건 1은 만족하지 않지만 조건 2 --> do2
조건 1, 2 는 X, 조건 3 --> do3

if (2의 배수){
    2
}
else if (3){       
    odd 3
}
else if(5){
   2x 3x 5
}



## md
- markdown